= Basics
:experimental:

In this chapter, you'll be introduced to the Spin programming language.

A computer is programmed by giving it instructions, one after the other, 

Once you've written a program, it is transformed into a form that a computer can read by a compiler. To run it, you have to download the code to the board in order to run it.

In PropellerIDE, simply press kbd:[F10] and in a few moments, the LameStation will run your code.

The examples in this section can be found in the `demos/basics/` folder of the LameStation SDK.


==  I'm Alive!

Having to write out specific values every time you need them is starting to become a problem. In the previous example, you had to write `24` three times and `10000` twice. Unless those values stay the same forever (which they might not, especially for the "10000", a value you may want to adjust), you'll have to update them everywhere they are used. Not only that, but you'll always have to remember what they mean, which is next to impossible if your code is more than a few lines long.

Luckily, there's a way around this problem.

===  Introducing `CON` blocks

`PUB` isn't the only kind of block available. `CON` blocks allow you to set _constant_ values, that don't change, allowing you to call them by name. 

Setting a constant is easy. Constant names can contain letters, numbers, and underscores (`_`), but must start with a letter or underscore.

Let's set constants for the LED pin and the count of times `repeat` will run before continuing. You can set as many as you want, but they must be inside a `CON` block.

    CON
        LED_PIN = 24
        COUNT   = 1000

There can also be as many `CON` blocks as you like too.
    
    CON
        LED_PIN = 24
    CON
        COUNT   = 1000

It works exactly the same, but now if we need to change the values, we only need to change them in one place.

----
CON
    LED_PIN = 24
    COUNT   = 1000

PUB Main
    dira[LED_PIN]~~

    repeat
        outa[LED_PIN]~
        repeat COUNT

        outa[LED_PIN]~~
        repeat COUNT
----

[TIP]
.Style is important
====
You may have noticed that all the constants are in capital letters when Spin is case-insensitive.

Why? It makes it easier to remember that it's a constant value.
====

=== Introducing `OBJ` blocks

Sometimes it's helpful to put code into a separate file. That way, if you have a nice piece of code that does something useful, you don't have to keep rewriting it for every project you work on. Instead, you can use it from where it is. Spin allows us to do this using the `OBJ` block. `OBJ` is short for _object_, because code files are called "objects" in Spin lingo.

To include an object in your code, you will need to provide the name of the file in quotes, and a short name under which you'd like to use the object. In our case, we'd like to add the file `LamePinout.spin` which contains pin assignments for the LameStation board. You can include the `.spin` extension or not, but the include file _must_ be a Spin file.

    OBJ
        pin : "LamePinout"

Now that you have the object included, you will be able to use the functions and constants inside of it.

To call a function in another object, prefix the short name of the included object, separating it with a period (`.`).

    PUB Main
        pin.Null

To get the value of a constant in another object, add the short name and the hash symbol (`#`). Here's us grabbing the pin assignment for the LED from `LamePinout.spin`.
    
    CON
        VALUE = pin#LED

So now let's set `LED_PIN` to `pin#LED` instead of having to remember what the pin is ourselves.

.ImAlive.spin
----
OBJ
    pin : "LamePinout"

CON
    LED_PIN = pin#LED
    COUNT   = 10000

PUB Main
    dira[LED_PIN]~~
    repeat
        outa[LED_PIN]~
        repeat COUNT

        outa[LED_PIN]~~

        repeat COUNT
----

Woohoo!

[TIP]
.Fun Fact
This happens to be the example that comes pre-loaded on every LameStation unit!

==  Take Control!

Now that we've learned how to include objects, let's look a little further into what's inside the LameStation SDK. In this example, we see how to control the LED using the buttons and joystick on the LameStation.

Introducing link:LameControl.adoc[LameControl]! LameControl is a
small library for getting user input for your application. Setting it up is straight forward; just include it in your application.

----
OBJ
    ctrl    : "LameControl"
----

link:ctrl.Update.adoc[ctrl.Update] saves the current state of all the
controls, so you can use them. Without using this command, LameControl
does nothing, so make sure you call it. At the beginning of your loop is a good place for it.

----
    repeat
        ctrl.Update
----

Now you can see if any of the buttons have been pressed. However, before you'll be able to see anything interesting happen, you need a way to test _if_ a button has been pressed.

You may have guessed that the keyword `IF` does just that. It allows you to only run code if a condition is true. Then, you can use the `ELSE` to run code if it is false.

So here's how to test if any button has been pressed. The light turns off if it has, or stays on if it hasn't.

----
        if ctrl.A or ctrl.B or ctrl.Up or ctrl.Down or ctrl.Left or ctrl.Right
            outa[LED_PIN]~~
        else
            outa[LED_PIN]~
----

So let's put it all together and put it to the test.

.TakeControl.spin
----
OBJ
    ctrl : "LameControl"
    pin  : "LamePinout"

CON
    LED_PIN = pin#LED

PUB Main

    dira[LED_PIN]~~

    repeat
        ctrl.Update

        if ctrl.A or ctrl.B or ctrl.Up or ctrl.Down or ctrl.Left or ctrl.Right
            outa[LED_PIN]~~
        else
            outa[LED_PIN]~
----