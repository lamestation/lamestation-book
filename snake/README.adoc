= Snake
:experimental:





== Moving forward



----
VAR    
    byte    snakedir    
    byte    snakex
    byte    snakey
----


----
        if snakedir == 3
            snakex--
                
        if snakedir == 1
            snakex++

        if snakedir == 0
            snakey--
                
        if snakedir == 2
            snakey++
----

This is cool, except the snake is able to just wander outside of the screen whenever it feels like! Let's show that snake who's boss by keeping it inside the screen.
----
        if snakedir == 3
            if snakex[0] > 0
                snakex[0]--
                
        if snakedir == 1
            if snakex[0] < constant(128-2)
                snakex[0]++

        if snakedir == 0
            if snakey[0] > 0
                snakey[0]--
                
        if snakedir == 2
            if snakey[0] < constant(64-2)
                snakey[0]++
----

== Leading the march

Two bytes for x and y clearly won't be enough. We have a whole army of pixels that make up this snake, so we're going to need arrays to hold them. We'll want to define one, but first, let's add a constant for the maximum number of snakes. This is important, because without it, it's chaos trying to remember how many are allowed throughout your program.

----
    MAX_SNAKE = 256
----

Now let's trick out the snake variables.

----
    byte    snakex[MAX_SNAKE]
    byte    snakey[MAX_SNAKE]
----

Oh, and one more thing. We need to keep track of how many snake dots there are on the screen.

----
    byte    snakecount
----

In snake, every frame, the snake moves forward one pixel, like this.

----
o o o o o
  o o o o o
    o o o o o
----

So how do we emulate that?

We add this code to test 

----
        if ctrl.A
            if snakecount < constant(MAX_SNAKE-1)
                snakecount++
----

repeat i from 1 to snakecount

----> 

doesn't work

repeat i from snakecount to 1

<----

works

----
o o o o o
 \ \ \ \ \
  o o o o o
----

Going further
****

How could we make this game more efficient? Is it necessary?

----
o o o o o
  | | | |
  o o o o o
----

****

----
    byte    i
----

----
            repeat i from snakecount to 1
                snakex[i] := snakex[i-1]
                snakey[i] := snakey[i-1]
                gfx.Sprite(@dot_gfx, snakex[i], snakey[i], 0) 
----


== A goal to strive for

// THIS SECTION TEACHES RANDOM NUMBER GENERATION

Pointlessly wandering around the screen is fun and everything, but I think it'll be more interesting to actually have something to do. I was thinking let's give the snake a food pellet or something to chase after, yeah?

Let's make the food a different color, so it'll be easier to spot. These graphics are just as exciting as the snake's.

----
    food_gfx
    word    0
    word    2, 2
    word    %%22222233
    word    %%22222233
----

Then we gotta keep track of the food's position on the screen ("foody", lol).

----
    byte    foodx
    byte    foody
----

Now, every time we get the food pellet, it has to reappear in a new location. For that, we need the _random_ operator! Setting it up may not make sense at first, but it's pretty simple. First, we need a variable.

----
    byte    random
----

First, we need to initialize it with a starting value. The system clock works perfectly for this.

----
    random := cnt
----

After that, we can grab random values from the `random` variable using the `?` operator. Use the following code to test it out.

----
if ctrl.B
    foodx := random?
    foody := random?
----

Problem. It seems to only work part of the time; sometimes dot, sometimes no dot. That's because `random?` is a byte, and can return random values between 0 and 255, so we need to limit its range. Modulo is perfect for this.

----
    foodx := random? // 128
    foody := random? // 64
----

It still only works half the time! This is because `random` is a byte, and for arithmetic, if it holds a value greater than 127, it's actually a negative number, so it won't ever appear on the screen. We can sidestep this problem with the _absolute value_ (`||`) operator. It forces the number to be positive, so our range will appear on the screen.

----
    foodx := ||random? // 128
    foody := ||random? // 64
----

There's still one problem though. Our snake is positioned every two pixels, but the food can be anywhere. Let's fix that.

----
    foodx := ||random? // 64 * 2
    foody := ||random? // 32 * 2
----

Perfect! Now let's add a test so that this code is only called when the snake finally grabs it.

----
if foodx == snakex[0] and foody == snakey[0]
----

Now our entire foody system should be complete.

----
        if foodx == snakex[0] and foody == snakey[0]
            foodx := ||random? // 64 * 2
            foody := ||random? // 32 * 2

            if snakecount < constant(MAX_SNAKE-1)
                snakecount++

        gfx.Sprite(@food_gfx, foodx, foody, 0) 
----


== Going faster

----
        if snakedir == 3
            if snakex[0] > 0
                snakex[0] += SNAKE_SPEED
                
        if snakedir == 1
            if snakex[0] < constant(128-2)
                snakex[0] += SNAKE_SPEED

        if snakedir == 0
            if snakey[0] > 0
                snakey[0] -= SNAKE_SPEED
                
        if snakedir == 2
            if snakey[0] < constant(64-2)
                snakey[0] += SNAKE_SPEED
----

Aww, man, but now it goes way fast at the beginning and slow at the end. Let's slow down the frame rate so that it plays at the same speed throughout.

----
    lcd.SetFrameLimit (lcd#HALFSPEED)
----

== The danger zone

So far, the snake is free to come and go as it pleases, criss-crossing over itself like nobody's business. Well, it's time to put a stop to that. Let's show this snake that there are consequences to dilly-dallying.

The change is simple enough. We want the snake to die if it crosses over itself. This can be accomplished by checking each pixel of the snake to see if it overlaps with the head.

----
            if snakex[i] == snakex[0] and snakey[i] == snakey[0]
                snakecount := 1
----

We just need to add it into the loop we've already created that moves the entire snake every frame.

----
        repeat i from snakecount to 1
            if snakex[i] == snakex[0] and snakey[i] == snakey[0]
                snakecount := 1
                snakex[0] := 64
                snakey[0] := 32
                snakedir := 1

            snakex[i] := snakex[i-1]
            snakey[i] := snakey[i-1]
            gfx.Sprite(@dot_gfx, snakex[i], snakey[i], 0)
----

Done. Now your snake will suffer an untimely fate for its carelessness. But we should tie up all its loose ends before it starts a new game.

== The Completed Game

----
CON
    _clkmode = xtal1|pll16x
    _xinfreq = 5_000_000
    
    MAX_SNAKE = 256
    SNAKE_SPEED = 2

OBJ
    lcd  : "LameLCD"
    gfx  : "LameGFX"
    ctrl : "LameControl"
    
VAR    
    byte    snakedir    
    byte    snakex[MAX_SNAKE]
    byte    snakey[MAX_SNAKE]
    byte    snakecount
    
    byte    foodx
    byte    foody
    
    byte    i
    byte    random
    
PUB Main
    lcd.Start(gfx.Start)
    lcd.SetFrameLimit (lcd#HALFSPEED)
    
    random := cnt
    
    foodx := ||random? // 64 * 2
    foody := ||random? // 32 * 2

    snakex[0] := 64
    snakey[0] := 32
    snakedir := 1
    snakecount := 1

    repeat        
        gfx.Clear
        ctrl.Update
        
        if snakedir == 0 or snakedir == 2
            if ctrl.Left
                snakedir := 3
            elseif ctrl.Right
                snakedir := 1

        elseif snakedir == 1 or snakedir == 3
            if ctrl.Up
                snakedir := 0
            elseif ctrl.Down
                snakedir := 2


        if snakedir == 3
            if snakex[0] > 0
                snakex[0] -= SNAKE_SPEED
                
        if snakedir == 1
            if snakex[0] < constant(128-2)
                snakex[0] += SNAKE_SPEED

        if snakedir == 0
            if snakey[0] > 0
                snakey[0] -= SNAKE_SPEED
                
        if snakedir == 2
            if snakey[0] < constant(64-2)
                snakey[0] += SNAKE_SPEED

        
        if foodx == snakex[0] and foody == snakey[0]
            foodx := ||random? // 64 * 2
            foody := ||random? // 32 * 2

            if snakecount < constant(MAX_SNAKE-1)
                snakecount++

        gfx.Sprite(@food_gfx, foodx, foody, 0) 

    
        repeat i from snakecount to 1
            if snakex[i] == snakex[0] and snakey[i] == snakey[0]
                snakecount := 1
                snakex[0] := 64
                snakey[0] := 32
                snakedir := 1

            snakex[i] := snakex[i-1]
            snakey[i] := snakey[i-1]
            gfx.Sprite(@dot_gfx, snakex[i], snakey[i], 0)
            
        gfx.Sprite(@dot_gfx, snakex[0], snakey[0], 0) 
        
        lcd.DrawScreen

DAT

    dot_gfx
    word    0
    word    2, 2
    word    %%22222211
    word    %%22222211

    food_gfx
    word    0
    word    2, 2
    word    %%22222233
    word    %%22222233
----

== Going further

There's clearly a lot more that could be done. You could add walls to crash into, fancier graphics, a snake that looks and feels like a real snake, the world is your oyster. What would you do next?

- Cleaning up the code

