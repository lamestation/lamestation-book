== Leading The March

In Snake, for every frame, the snake moves forward one pixel, with each pixel following after it.

----
■ ■ ■ ■ ■           ' frame 1

  ■ ■ ■ ■ ■         ' frame 2

    ■ ■ ■ ■ ■       ' frame 3
----

So how do we emulate that? We basically need to do everything we've done up to this point, times however long the snake is. Two bytes for x and y clearly won't be enough. We're going to need arrays.

We'll want to define one, but first, let's add a constant for the maximum number of snakes. This is important, because without it, it's chaos trying to remember how many are allowed throughout your program.

First, decide how long the snake can be. We need to know how big to make the arrays. 256 seems pretty big, but on a 128x64 screen, there are *8192 pixels*!

----
CON
    MAX_LENGTH = 256
----

We turn our `snakex` and `snakey` variables into arrays.

----
VAR
    byte    snakex[MAX_SNAKE]
    byte    snakey[MAX_SNAKE]
----

Since the snake starts small and grows, we also need to keep track of how many snake dots there are on the screen at any time.

----
    byte    snakecount
----

We're going to add a variable called `i`. This one is just used for our `repeat` loop.

----
    byte    i
----

----
            repeat i from snakecount to 1
                snakex[i] := snakex[i-1]
                snakey[i] := snakey[i-1]
                gfx.Sprite(@dot_gfx, snakex[i], snakey[i], 0) 
----



We add this code to test 

----
        if ctrl.A
            if snakecount < constant(MAX_SNAKE-1)
                snakecount++
----

repeat i from 1 to snakecount

----> 

doesn't work

repeat i from snakecount to 1

<----

works

----
■ ■ ■ ■ ■
 \ \ \ \ \
  ■ ■ ■ ■ ■
----

Going further
****

How could we make this game more efficient? Is it necessary?

----
■ ■ ■ ■ ■
  | | | |
  ■ ■ ■ ■ ■
----

****